{% extends "base.html" %}

{% block content %}

<!-- main content -->
<main class="container">
    <div class="content">

        <div class="row" style="margin-top: 32px;">

            <div class="col-md-3">
                <label for="analysis_name" class="form-label">Analysis name</label>
                <input type="text" class="form-control" id="analysis_name" name="analysis_name" value="{{ analysis_name }}" disabled>
            </div>

            <div class="col-md-6">
                <label for="network_id" class="form-label">Network</label>
                <input type="text" class="form-control" id="network" name="network" value="{{ network.name }}" disabled>
            </div>

            <div class="col-md-3">
                <label for="network_id" class="form-label">Analysis type</label>
                <input type="text" class="form-control" id="network" name="network" value="{{ analysis_type }}" disabled>
            </div>

        </div>

        <div class="row" style="margin-top: 32px;">
            <!-- map -->
            <div class="col-sm-12">
                <!-- XXX: hacky hardocded -->
                <div id="map_id" style="height: 950px; width=100%; border-radius: 8px;"></div>

            </div>
        </div>

    </div>

<style>
.legend { text-align: left; line-height: 18px; color: #555; } .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; }</style>
</style>
</main>

<script>
    var defaultLatLng = new L.LatLng(47.263, 11.404)

    var url = 'https://{s}.wien.gv.at/basemap/bmaporthofoto30cm/normal/google3857/{z}/{y}/{x}.jpeg',
        attrib = 'Datenquelle: <a href="https://basemap.at">basemap.at</a>',
        tilelayer = L.tileLayer(url, { maxZoom: 22, attribution: attrib, subdomains: ['maps1', 'maps2', 'maps3', 'maps4']}),

    map = new L.Map('map_id', { center: defaultLatLng, zoom: 14 });
    drawnItems = L.featureGroup().addTo(map);

    tilelayer.addTo(map);

    let color_ramp = {{ color_ramp|safe }};
    console.log(color_ramp);

    function getColor(d) {
        for (let i=color_ramp.length-1; i>=0; i--) {
            if (d >= color_ramp[i][0]) {
                return color_ramp[i][1];
            }
        }

        return color_ramp[0][1];
        /*
        return d > 1000 ? '#800026' :
               d > 500  ? '#BD0026' :
               d > 200  ? '#E31A1C' :
               d > 100  ? '#FC4E2A' :
               d > 50   ? '#FD8D3C' :
               d > 20   ? '#FEB24C' :
               d > 10   ? '#FED976' :
                          '#FFEDA0';
        */
    }

    var links_geojson = {{ links_geojson|safe }};
    var nodes_geojson = {{ nodes_geojson|safe }};

    console.log(links_geojson)

    let nodes = L.geoJson(nodes_geojson, {
        pointToLayer: function (feature, latlng) {
            let node_type = feature.properties.type;
            return L.circleMarker(latlng, {
                opacity: 0.0,
                radius: 2,
                fillColor: '#000088',
                fillOpacity: 0.5,
            });
        },
    });

    var atype = "{{ analysis_type }}";
    console.log(atype);

    let links = L.geoJson(links_geojson, {
        style: function(feature) {
            //return {color: color_ramp_dict[d] || '#000000'}
            //XXX: hacky

            if (atype === 'single_pipe_failure_epanet') {
                return {color: getColor(feature.properties.junctions_impacted.length)}
            }
            else {
                return {color: getColor(feature.properties.junctions_impacted)}
            }
            //return {color: '#000088'}
        },
        onEachFeature: function(feature, layer) {
            let content = '<p>';
            //XXX: hacky
            if (atype === 'single_pipe_failure_epanet') {
                content += '<span style="font-weight: bold;">#Junctions impacted:</span> ' + feature.properties.junctions_impacted.length;
            }
            else {
                content += '<span style="font-weight: bold;">#Junctions impacted:</span> ' + feature.properties.junctions_impacted;
            }
            content += '</p>';
            layer.bindPopup(content);
        }
    });

    let i = 0;
    links.eachLayer(function(){ i += 1; });
    console.log('Map has', i, 'layers.');

    links.on('click', function(e) {
        //console.log(e);

        var properties = e.layer.feature.properties;
        console.log(properties);

        // get the point ids associated with the line
        var pointIds = properties.junctions_impacted;
        console.log(pointIds)

        var n = 0;

        // iterate over the point layer and change the color of the associated points
        nodes.eachLayer(function (layer) {
            if (pointIds.includes(layer.feature.properties.id)) {
                layer.setStyle({
                    opacity: 0.0,
                    radius: 5,
                    fillColor: 'red',
                    fillOpacity: 1.0,
                });
                n += 1;
            }
            else {
                layer.setStyle({
                    opacity: 0.0,
                    radius: 2,
                    fillColor: '#000088',
                    fillOpacity: 0.5,
                });
            }
        });

        console.log(n);
    });

    drawnItems.addLayer(links);
    drawnItems.addLayer(nodes);

    map.fitBounds(drawnItems.getBounds());

</script>

{% endblock %}
